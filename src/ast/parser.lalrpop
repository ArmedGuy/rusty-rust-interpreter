use std::str::FromStr;

use crate::ast::*;

grammar;

match {
    // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"\s*" => { }, 
    // Skip `// comments`
    r"//[^\n\r]*" => { }, 
    // Skip `/* comments */`
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },  
    "i32",
    "bool",
    "{",
    "}",
    "()",
    "(",
    ")",
    ";",
    "-",
    "+",
    "*",
    "/",
    ",",
    "!",
    "&&",
    "||",
    "==",
    "=",
    "<",
    ">",
    ":",
    r"[0-9]+",
    r"([a-z_]|[A-Z])([a-z]|[A-Z]|[0-9]|_)*",
    "true",
    "false",
    "fn",
    "while",
    "if",
    "else",
    "else if",
    "return",
    "let",
    "mut",
    "->",
    _
}


// Primitives
pub Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap(),
};

pub Bool: bool = {
    "true" => true,
    "false" => false
}

Identifier: String = {
    r"([a-z_]|[A-Z])([a-z]|[A-Z]|[0-9]|_)*" => String::from_str(<>).unwrap(),
};


// Expression
pub ExtendedExpr: Box<Expr> = {
    Expr,
    BlockStatement => Box::new(Expr::BlockExpr(<>)),
    ConditionalStatement => Box::new(Expr::ConditionalExpr(<>)),
};
pub Expr: Box<Expr> = {
    //NumExpr,
    //BoolExpr,
    CalculatedExpr,
};

// calculated expressions
CalculatedExpr: Box<Expr> = {
    CalculatedExpr BoolExprOp CalculatedTerm => Box::new(Expr::Op(<>)),
    CalculatedExpr BoolExprRetOp CalculatedTerm => Box::new(Expr::Op(<>)),
    CalculatedExpr ExprOp CalculatedFactor => Box::new(Expr::Op(<>)),
    CalculatedFactor,
};

CalculatedFactor: Box<Expr> = {
    CalculatedFactor FactorOp CalculatedTerm => Box::new(Expr::Op(<>)),
    CalculatedTerm
};

CalculatedTerm: Box<Expr> = {
    FuncExpr,
    BoolTerm,
    NumTerm,
    Identifier => Box::new(Expr::Identifier(<>)),
    <ModExprOp> <CalculatedTerm> => Box::new(Expr::ModOp(<>)),
    "(" <CalculatedExpr> ")",
};

ModExprOp: Opcode = {
    "!" => Opcode::Neg,
    "-" => Opcode::Sub,
}

ExprOp: Opcode = { // (3)
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

NumTerm: Box<Expr> = {
    Num => Box::new(Expr::Number(<>)),
};
BoolTerm: Box<Expr> = {
    Bool => Box::new(Expr::Boolean(<>)),
};

BoolExprOp: Opcode = {
    "&&" => Opcode::And,
    "||" => Opcode::Or,
    "==" => Opcode::Is,
};

BoolExprRetOp: Opcode = {
    "<" => Opcode::LessThen,
    ">" => Opcode::GreaterThen,
};

Exprs = Comma<Expr>; // (0)

Comma<T>: Vec<T> = { // (1)
    <v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

FuncExpr: Box<Expr> = {
    <i:Identifier> "(" <e:Exprs> ")" => Box::new(Expr::Function(i, e)),
    <i:Identifier> "()" => Box::new(Expr::Function(i, vec![])),
};

Type: Typedef = {
    "()" => Typedef::Unit,
    "bool" => Typedef::Bool,
    "i32" => Typedef::I32,
}

VarDef: Box<Statement> = {
    <i:Identifier> ":" <t:Type> => Box::new(Statement::VarDef(i, t))
}

// Statement
pub Statement: Box<Statement> = {
    <i:IStatement> => i,
};

IStatement: Box<Statement> = {
    <FuncStatement> ";"?,
    <DefineStatement> ";",
    <AssignStatement> ";",
    <ConditionalStatement> ";"?,
    <LoopStatement> ";"?,
    <e:Expr> ";" => Box::new(Statement::Expr(e))
};

ReturnStatement: Box<Statement> = {
    "return" <e:Expr> ";"? => Box::new(Statement::Return(e)),
    <e:Expr> => Box::new(Statement::Return(e))
}

FuncArgs = Comma<VarDef>;

pub FuncStatement: Box<Statement> = {
    "fn" <Identifier> "(" <FuncArgs> ")" <("->" <Type>)?> <BlockStatement> => Box::new(Statement::Function(<>)),
    "fn" <i:Identifier> "()" <t:("->" <Type>)?> <b:BlockStatement> => Box::new(Statement::Function(i, vec![], t, b)),
};

BlockStatement: Box<Statement> = {
    "{" <Statement*> <ReturnStatement?>"}" => Box::new(Statement::Block(<>)),
};

DefineStatement: Box<Statement> = {
    "let" "mut" <v:VarDef> "=" <e:ExtendedExpr> => Box::new(Statement::Definition(true, v, e)),
    "let" <v:VarDef> "=" <e:ExtendedExpr> => Box::new(Statement::Definition(false, v, e)),
};

AssignStatement: Box<Statement> = {
    <i:Identifier> "=" <e:ExtendedExpr> => Box::new(Statement::Assignment(i, e)),
};

ConditionalStatement: Box<Statement> = {
    "if" <e:Expr> <b:BlockStatement> <next:NextConditionalStatement?> => Box::new(Statement::Conditional(ConditionalType::If, Some(e), b, next))
};

NextConditionalStatement: Box<Statement> = {
    ElseIfStatement,
    ElseStatement
};

ElseIfStatement: Box<Statement> = {
    "else if" <e:Expr> <b:BlockStatement> <next:NextConditionalStatement?> => Box::new(Statement::Conditional(ConditionalType::ElseIf, Some(e), b, next))
};

ElseStatement: Box<Statement> = {
    "else" <b:BlockStatement> => Box::new(Statement::Conditional(ConditionalType::Else, None, b, None))
};

LoopStatement: Box<Statement> = {
    "while" "(" <e:Expr> ")" <b:BlockStatement> => Box::new(Statement::WhileLoop(e, b))
};

pub Program: Box<Statement> = {
    Statement+ => Box::new(Statement::Program(<>))
}